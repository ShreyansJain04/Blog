[
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/change_of_variables.html#its-importance",
    "href": "posts/change_of_variables.html#its-importance",
    "title": "Change of Variables with Jacobian Matrix",
    "section": "Its Importance:",
    "text": "Its Importance:\n\nWe often change the variables in math to make integrals easier to solve. But there’s another reason for doing this – to make the area or volume we’re working with more convenient to handle. When we switch to polar, cylindrical, or spherical coordinates, it’s usually straightforward to figure out the new boundaries of the area or volume. However, this isn’t always the case. So, before we jump into using variable changes in multiple integrals, we first need to understand how these changes affect the shape and size of the region we’re working with.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef linear_transformation(x, y):\n    u = 2*x + y\n    v = x - y\n    return u, v\n\n\nx_range = np.linspace(-5, 5, 100)\ny_range = np.linspace(-5, 5, 100)\nx, y = np.meshgrid(x_range, y_range)\nu, v = linear_transformation(x, y)\n# Jacobian matrix for the linear transformation\nJacobian = np.array([[2, 1],\n                     [1, -1]])\nplt.figure(figsize=(10, 5))\n# Original grid\nplt.subplot(1, 2, 1)\nplt.title(\"Original Grid (x, y)\")\nplt.quiver(x, y, np.ones_like(x), np.zeros_like(y), scale=10, scale_units='xy')\nplt.xlim(-5, 5)\nplt.ylim(-5, 5)\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\n\n# Transformed grid\nplt.subplot(1, 2, 2)\nplt.title(\"Transformed Grid (u, v)\")\nplt.quiver(u, v, np.ones_like(u), np.zeros_like(v), scale=10, scale_units='xy')\nplt.xlim(-10, 10)\nplt.ylim(-10, 10)\nplt.xlabel(\"u\")\nplt.ylabel(\"v\")\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef nonlinear_transformation(x, y):\n    u = x\n    v = 6 * y  # Scale the y-coordinate by a factor of 6\n    return u, v\n\n\nx_range = np.linspace(-5, 5, 1000)\ny_range = np.linspace(-5, 5, 1000)\nx, y = np.meshgrid(x_range, y_range)\nu, v = nonlinear_transformation(x, y)\n\nplt.figure(figsize=(10, 5))\n# Original grid\nplt.subplot(1, 2, 1)\nplt.title(\"Original Grid (x, y)\")\n# Plot the original ellipse with the correct contour level\nplt.contour(x, y, x**2 + (y/6)**2, levels=[1], colors='b')\nplt.xlim(-5, 5)\nplt.ylim(-50, 50)  # Adjust the y-coordinate range\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\n\n# Transformed grid\nplt.subplot(1, 2, 2)\nplt.title(\"Transformed Grid (u, v)\")\n# Plot the transformed circle\nplt.contour(u, v, u**2 + v**2, levels=[1], colors='r')\nplt.xlim(-10, 10)\nplt.ylim(-10, 10)  # Adjust the y-coordinate range for visualization\nplt.xlabel(\"u\")\nplt.ylabel(\"v\")\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define ellipse equation: x^2 + y^2 / 36 = 1\na = 6  # Semi-major axis length\nb = 6  # Semi-minor axis length\n\n# Generate grid\nx = np.linspace(-10, 10, 200)\ny = np.linspace(-10, 10, 200)\nX, Y = np.meshgrid(x, y)\n\n# Define ellipse equation\nellipse = X**2 + Y**2 / b**2 - 1\n\n# Define arrow properties\narrow_length = 0.5\narrow_color = 'gray'\narrow_alpha = 0.5\nnum_arrows = 20  # Number of arrows\n\n# Compute arrow positions\narrow_positions = np.linspace(0, len(x) - 1, num_arrows, dtype=int)\n\n# Apply transformation: u = x, v = 6*y\nU = X\nV = 6 * Y\n\n# Define transformed circle equation\ncircle = U**2 + V**2 - a**2\n\n# Define arrow directions (all pointing in a single direction)\n# Change this value to -1 to reverse the direction\narrow_direction = np.array([1])\n\n# First plot: Ellipse with uniform arrows\nplt.figure(figsize=(8, 8))\nplt.contour(X, Y, ellipse, levels=[1], colors='b',\n            linestyles='dashed', label='Ellipse')\nplt.quiver(X[arrow_positions[:, np.newaxis], arrow_positions], Y[arrow_positions[:, np.newaxis], arrow_positions],\n           arrow_direction, arrow_direction,\n           scale=10, pivot='mid', color=arrow_color, alpha=arrow_alpha, label='Arrows')\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.title('Ellipse with Uniform Arrows')\nplt.legend()\nplt.axis('equal')\nplt.grid(True)\nplt.show()\n\n# Second plot: Transformed Circle with uniform arrows\nplt.figure(figsize=(8, 8))\nplt.contour(U, V, circle, levels=[1], colors='r',\n            linestyles='solid', label='Circle')\nplt.quiver(U[arrow_positions[:, np.newaxis], arrow_positions], V[arrow_positions[:, np.newaxis], arrow_positions],\n           arrow_direction, arrow_direction,\n           scale=10, pivot='mid', color=arrow_color, alpha=arrow_alpha, label='Arrows')\nplt.xlabel('U')\nplt.ylabel('V')\nplt.title('Transformed Circle with Uniform Arrows')\nplt.legend()\nplt.axis('equal')\nplt.grid(True)\nplt.show()\n\nC:\\Users\\asus\\AppData\\Local\\Temp\\ipykernel_14680\\3513024967.py:37: UserWarning: The following kwargs were not used by contour: 'label'\n  plt.contour(X, Y, ellipse, levels=[1], colors='b', linestyles='dashed', label='Ellipse')\nC:\\Users\\asus\\AppData\\Local\\Temp\\ipykernel_14680\\3513024967.py:51: UserWarning: The following kwargs were not used by contour: 'label'\n  plt.contour(U, V, circle, levels=[1], colors='r', linestyles='solid', label='Circle')\n\n\n\n\n\n\n\n\nThe above plots demonstrate how the grid changes and figures are transformed after changing variables using the jacobian. Next we see how transforming each unit rectangle using eulers method actually gives us the area of the ellipse that is piab. This is an example case of how jacobian determinant can help us transform figures to more workable ones to find area easily\n\nimport numpy as np\n\nb = 6\n\nx = np.linspace(-10, 10, 200)\ny = np.linspace(-10, 10, 200)\nX, Y = np.meshgrid(x, y)\n\nellipse = X**2 + Y**2 / b**2 - 1\n\nU = X\nV = 6 * Y\njacobian_det = 6\ncircle = U**2 + V**2 - 1\n\ndx = x[1] - x[0]\ndy = y[1] - y[0]\nellipse_area = 0.0\n\nfor i in range(len(x)-1):\n    for j in range(len(y)-1):\n        if ellipse[i, j] &lt;= 0:\n            ellipse_area += dx * dy\n\nprint(\"Approximated area of the ellipse using Euler's method: {:.2f}\".format(\n    ellipse_area))\n\ncircle_area = 0.0\n\nfor i in range(len(x) - 1):\n    for j in range(len(y) - 1):\n        if circle[i, j] &lt;= 0:\n            circle_area += dx * dy*jacobian_det  # to transform dx dy to du dv\n\nprint(\"Approximated area of the circle in the transformed domain: {:.2f}\".format(\n    circle_area))\n\nApproximated area of the ellipse using Euler's method: 18.95\nApproximated area of the circle in the transformed domain: 3.15\n\n\nWe see that the area of circle comes out to be nearly pi, when we will multiply this by jacobian determinat to the final area of ellipse, we will get pi16 = 6pi, which is the area of ellipse. Therefore we saw how integration will work when two integrals are present and we simplify using jacobian determinant. Int(int(complex function))=int(int(transformed function))*jacobian determinant"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blogs",
    "section": "",
    "text": "Change of Variables with Jacobian Matrix\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nPost With Code\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nOct 24, 2023\n\n\nHarlow Malloc\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nOct 21, 2023\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  }
]
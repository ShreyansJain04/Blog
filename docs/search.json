[
  {
    "objectID": "posts/[Paper Review] ImageNet Classification with Deep C 1b0f01074320435c8e31aa28118c2a1c.html",
    "href": "posts/[Paper Review] ImageNet Classification with Deep C 1b0f01074320435c8e31aa28118c2a1c.html",
    "title": "[Paper Review] ImageNet Classification with Deep Convolutional Neural Networks (2012)",
    "section": "",
    "text": "Neural Networks (2012)\n\n\n\n\n\n\nThe AI community back in 2006 had this common belief, “a better algorithm would make better decisions, regardless of the data.” As we know nothing happens unanimously, there were critics regardingFei Fei Li who thought otherwise. According to her, “the best algorithm wouldn’t work well if the data it learned from didn’t reflect the real world”. So she set out to test out her hypothesis with a small team. The first instance of ImageNet was published as a research poster in 2009, it was a large scale image database. The philosophy behind ImageNet model is that we should for once shift our attendance from models to data. The dataset took two and a half years to complete. It consisted of 3.2 million labelled images, separated into 5,247 categories, sorted into 12 subtrees like “mammal,” “vehicle,” and “furniture.” It later evolved to 15 million images and 22,000 categories when this paper was published.\n\n\n\nNear human like recognition capabilities had been achieved on small datasets of similar images like the MNIST database. But objects in real settings exhibit variability and hence require a very large database. As I mentioned earlier for the first time, a one of a kind database was published that had millions of labeled images. An annual competition called the ImageNet Large-Scale Visual Recognition Challenge (ILSVRC) has been held which led the team of highly motivated researchers to finally pick up the challenge. The current models were also prohibitively large and expensive to train.\n\n\n\nThe model developed was named AlexNet by the authors. The complete details of developing it are:\n\n\nThe ImageNet contained images of variable resolutions which presents major problems.\nNeural networks expect inputs to be of the same shape, hence require Using high res images may also present the problem of overfitting, reducing the complexity of data encourages the model to learn more generalised features. Eg a stone in a picture of a beach presents no significance but a high res image may force the network to also see it as a feature of a beach.\n\n\n\n\nThe nn consisted of 8 layers, 5 convolutional and 3 fully connected. This number was reached to ensure maximum accuracy and was observed that dropping even one of the fully connected layers presented a major decrease in accuracy.\nActivation Function: ReLU (Rectified liner Unit- max(0,x) ) was used as the activation function between the layers. The usual activation functions are sigmoid and tanh(x). But they present the challenge of saturation in the neural network. ReLU also allowed for faster training as its less computationally expensive.\n\nThe heart of neural network in a way lies in the activation function as it enables it to learn something non-linear. “Two dense layers with nothing in between are no better than a single dense layer by itself. Dense layers by themselves can never move us out of the world of lines and planes. What we need is something nonlinear. What we need are activation functions.”\n\nParallelizing Training: The state of the art GPU was a GTX 580 3GB (Which was succeeded with a superior GTX 680 just two months after the release of the paper). The GPUs were connected in SLI which enabled to read and write to each others memory without going to the host machine. The layers are connected in a way that tries to minimize communication between the GPUs while still enabling effective training. A schematic simplified representation is shown in the image below.\n\n\nPooling: Given below is how average pooling works here the stride=1 and neighborhood size=3, similarly Alexnet employed stride=2 and neighborhood size=3. Through hyperparameter tuning it was found that these particular values provided a performance boost. Additionally it was experimentally found that this helped prevent overfitting.\n\nLocal Response Normalization: Features that tend to produce activations of very different sizes can make for unstable training behavior. In shallow networks we often use scikit learns StandardScaler to bring the input on a similar scale so there is no bias due to magnitude of numeric values. Somewhat similar concept applies here, we normalize the responses in a certain neighborhood.\nnormalized_response = original_response / (k + alpha * sum(squared_responses)).\n\n\nk is a constant hyperparameter to avoid division by zero and control the amplification factor.\nalpha is a hyperparameter that determines the degree of normalization.\nsquared_responses represents the squared values of the responses within the local neighborhood window\n\nThis aids generalization and prevents overfitting. The purpose is to amplify the output of neurons that have relatively large activation. This practice has reduced nowadays and in fact, we have a special kind of layer that can do this, the batch normalization layer. A batch normalization layer looks at each batch as it comes in, first normalizing the batch with its own mean and standard deviation, and then also putting the data on a new scale with two trainable rescaling parameters. Batchnorm, in effect, performs a kind of coordinated rescaling of its inputs.\n\n\n\n\nThe network architecture consisted of 60 million parameters. Although the training set is large its insufficient to prevent overfitting. It was taken care of in the following to ways.\n\n\nThis refers to artificially increasing the size of the dataset. The stroke of genius here is that we can do so on free compute (time wise) the images are transformed on a cpu while the gpu is busy training the previous set of images . The data was augmented in two ways, the first was generating image translations and horizontal reflections. We do this by extracting random 224 × 224 patches (and their horizontal reflections) from the 256×256 images. The second is altering RGB values by PCA. To each image certain multiples of found pca components are added. This scheme works as an object lets say a chair is invariant to intensity of illumination or colour.\n\n\n\nOverfitting makes the model learn spurious patterns. Since these spurious patterns are so specific they are very easy to break if that particular neuron is deactivated. In dropout we randomly drop out some fraction of input units, this makes it very hard to overfit and more generalized patterns are learned as they are more prominent in every pass and are present even after dropout. Here dropout was kept at 50%. Although it does increase the number of iteration required.\n\n\n\n\nStochastic gradient descent was used. The batch size of 128, momentum of 0.9 and weight decay =0.0005.\nMomentum: Momentum is a technique that helps accelerate the convergence of the optimization process and overcome the local minima in the loss landscape. It simulates the behavior of a moving object with momentum. In the context of neural networks, it introduces a “velocity” term that influences the update of the model’s parameters.\nvelocity = momentum * velocity - learning_rate * gradient parameters = parameters + velocity\n\nvelocity represents the accumulated velocity from previous iterations.\nmomentum is a hyperparameter that determines the influence of the previous velocities on the current update.\nlearning_rate is the rate at which the model learns from the gradients.\ngradient represents the gradient of the loss function with respect to the parameters.\nparameters are the model’s weights and biases.\n\nDecay is to prevent the model from relying on any single feature, so its a penalty added to the loss function. parameters = parameters - learning_rate * (gradient + weight_decay * parameters)\nIt penalizes larger weights more.\nAlso the weights instead of being random were initialised as follows, “We initialized the weights in each layer from a zero-mean Gaussian distribution with standard deviation 0.01. We initialized the neuron biases in the second, fourth, and fifth convolutional layers, as well as in the fully-connected hidden layers, with the constant 1. “ This was to accelerated learning by providing ReLU with positive inputs.\n\n\n\nLearning rate was kept constant and manually adjusted by seeing the validation error rate.\nThe network won the ILSCVRC-2010 with top-1 and top-5test set error rates of 37.5% and 17.0%5.\n\n\n\nUse of unsupervised learning to find patterns in data could potentially help. Like setting weights based on it and then tuning it by supervised learning has the potential to increase the accuracy. Further doing this task on video sequences it can see how data evolves and can help in identifying features even better."
  },
  {
    "objectID": "posts/[Paper Review] ImageNet Classification with Deep C 1b0f01074320435c8e31aa28118c2a1c.html#background",
    "href": "posts/[Paper Review] ImageNet Classification with Deep C 1b0f01074320435c8e31aa28118c2a1c.html#background",
    "title": "[Paper Review] ImageNet Classification with Deep Convolutional Neural Networks (2012)",
    "section": "",
    "text": "The AI community back in 2006 had this common belief, “a better algorithm would make better decisions, regardless of the data.” As we know nothing happens unanimously, there were critics regardingFei Fei Li who thought otherwise. According to her, “the best algorithm wouldn’t work well if the data it learned from didn’t reflect the real world”. So she set out to test out her hypothesis with a small team. The first instance of ImageNet was published as a research poster in 2009, it was a large scale image database. The philosophy behind ImageNet model is that we should for once shift our attendance from models to data. The dataset took two and a half years to complete. It consisted of 3.2 million labelled images, separated into 5,247 categories, sorted into 12 subtrees like “mammal,” “vehicle,” and “furniture.” It later evolved to 15 million images and 22,000 categories when this paper was published."
  },
  {
    "objectID": "posts/[Paper Review] ImageNet Classification with Deep C 1b0f01074320435c8e31aa28118c2a1c.html#motivation",
    "href": "posts/[Paper Review] ImageNet Classification with Deep C 1b0f01074320435c8e31aa28118c2a1c.html#motivation",
    "title": "[Paper Review] ImageNet Classification with Deep Convolutional Neural Networks (2012)",
    "section": "",
    "text": "Near human like recognition capabilities had been achieved on small datasets of similar images like the MNIST database. But objects in real settings exhibit variability and hence require a very large database. As I mentioned earlier for the first time, a one of a kind database was published that had millions of labeled images. An annual competition called the ImageNet Large-Scale Visual Recognition Challenge (ILSVRC) has been held which led the team of highly motivated researchers to finally pick up the challenge. The current models were also prohibitively large and expensive to train."
  },
  {
    "objectID": "posts/[Paper Review] ImageNet Classification with Deep C 1b0f01074320435c8e31aa28118c2a1c.html#alexnet",
    "href": "posts/[Paper Review] ImageNet Classification with Deep C 1b0f01074320435c8e31aa28118c2a1c.html#alexnet",
    "title": "[Paper Review] ImageNet Classification with Deep Convolutional Neural Networks (2012)",
    "section": "",
    "text": "The model developed was named AlexNet by the authors. The complete details of developing it are:\n\n\nThe ImageNet contained images of variable resolutions which presents major problems.\nNeural networks expect inputs to be of the same shape, hence require Using high res images may also present the problem of overfitting, reducing the complexity of data encourages the model to learn more generalised features. Eg a stone in a picture of a beach presents no significance but a high res image may force the network to also see it as a feature of a beach.\n\n\n\n\nThe nn consisted of 8 layers, 5 convolutional and 3 fully connected. This number was reached to ensure maximum accuracy and was observed that dropping even one of the fully connected layers presented a major decrease in accuracy.\nActivation Function: ReLU (Rectified liner Unit- max(0,x) ) was used as the activation function between the layers. The usual activation functions are sigmoid and tanh(x). But they present the challenge of saturation in the neural network. ReLU also allowed for faster training as its less computationally expensive.\n\nThe heart of neural network in a way lies in the activation function as it enables it to learn something non-linear. “Two dense layers with nothing in between are no better than a single dense layer by itself. Dense layers by themselves can never move us out of the world of lines and planes. What we need is something nonlinear. What we need are activation functions.”\n\nParallelizing Training: The state of the art GPU was a GTX 580 3GB (Which was succeeded with a superior GTX 680 just two months after the release of the paper). The GPUs were connected in SLI which enabled to read and write to each others memory without going to the host machine. The layers are connected in a way that tries to minimize communication between the GPUs while still enabling effective training. A schematic simplified representation is shown in the image below.\n\n\nPooling: Given below is how average pooling works here the stride=1 and neighborhood size=3, similarly Alexnet employed stride=2 and neighborhood size=3. Through hyperparameter tuning it was found that these particular values provided a performance boost. Additionally it was experimentally found that this helped prevent overfitting.\n\nLocal Response Normalization: Features that tend to produce activations of very different sizes can make for unstable training behavior. In shallow networks we often use scikit learns StandardScaler to bring the input on a similar scale so there is no bias due to magnitude of numeric values. Somewhat similar concept applies here, we normalize the responses in a certain neighborhood.\nnormalized_response = original_response / (k + alpha * sum(squared_responses)).\n\n\nk is a constant hyperparameter to avoid division by zero and control the amplification factor.\nalpha is a hyperparameter that determines the degree of normalization.\nsquared_responses represents the squared values of the responses within the local neighborhood window\n\nThis aids generalization and prevents overfitting. The purpose is to amplify the output of neurons that have relatively large activation. This practice has reduced nowadays and in fact, we have a special kind of layer that can do this, the batch normalization layer. A batch normalization layer looks at each batch as it comes in, first normalizing the batch with its own mean and standard deviation, and then also putting the data on a new scale with two trainable rescaling parameters. Batchnorm, in effect, performs a kind of coordinated rescaling of its inputs."
  },
  {
    "objectID": "posts/[Paper Review] ImageNet Classification with Deep C 1b0f01074320435c8e31aa28118c2a1c.html#reducing-overfitting",
    "href": "posts/[Paper Review] ImageNet Classification with Deep C 1b0f01074320435c8e31aa28118c2a1c.html#reducing-overfitting",
    "title": "[Paper Review] ImageNet Classification with Deep Convolutional Neural Networks (2012)",
    "section": "",
    "text": "The network architecture consisted of 60 million parameters. Although the training set is large its insufficient to prevent overfitting. It was taken care of in the following to ways.\n\n\nThis refers to artificially increasing the size of the dataset. The stroke of genius here is that we can do so on free compute (time wise) the images are transformed on a cpu while the gpu is busy training the previous set of images . The data was augmented in two ways, the first was generating image translations and horizontal reflections. We do this by extracting random 224 × 224 patches (and their horizontal reflections) from the 256×256 images. The second is altering RGB values by PCA. To each image certain multiples of found pca components are added. This scheme works as an object lets say a chair is invariant to intensity of illumination or colour.\n\n\n\nOverfitting makes the model learn spurious patterns. Since these spurious patterns are so specific they are very easy to break if that particular neuron is deactivated. In dropout we randomly drop out some fraction of input units, this makes it very hard to overfit and more generalized patterns are learned as they are more prominent in every pass and are present even after dropout. Here dropout was kept at 50%. Although it does increase the number of iteration required."
  },
  {
    "objectID": "posts/[Paper Review] ImageNet Classification with Deep C 1b0f01074320435c8e31aa28118c2a1c.html#details-of-learning",
    "href": "posts/[Paper Review] ImageNet Classification with Deep C 1b0f01074320435c8e31aa28118c2a1c.html#details-of-learning",
    "title": "[Paper Review] ImageNet Classification with Deep Convolutional Neural Networks (2012)",
    "section": "",
    "text": "Stochastic gradient descent was used. The batch size of 128, momentum of 0.9 and weight decay =0.0005.\nMomentum: Momentum is a technique that helps accelerate the convergence of the optimization process and overcome the local minima in the loss landscape. It simulates the behavior of a moving object with momentum. In the context of neural networks, it introduces a “velocity” term that influences the update of the model’s parameters.\nvelocity = momentum * velocity - learning_rate * gradient parameters = parameters + velocity\n\nvelocity represents the accumulated velocity from previous iterations.\nmomentum is a hyperparameter that determines the influence of the previous velocities on the current update.\nlearning_rate is the rate at which the model learns from the gradients.\ngradient represents the gradient of the loss function with respect to the parameters.\nparameters are the model’s weights and biases.\n\nDecay is to prevent the model from relying on any single feature, so its a penalty added to the loss function. parameters = parameters - learning_rate * (gradient + weight_decay * parameters)\nIt penalizes larger weights more.\nAlso the weights instead of being random were initialised as follows, “We initialized the weights in each layer from a zero-mean Gaussian distribution with standard deviation 0.01. We initialized the neuron biases in the second, fourth, and fifth convolutional layers, as well as in the fully-connected hidden layers, with the constant 1. “ This was to accelerated learning by providing ReLU with positive inputs."
  },
  {
    "objectID": "posts/[Paper Review] ImageNet Classification with Deep C 1b0f01074320435c8e31aa28118c2a1c.html#results",
    "href": "posts/[Paper Review] ImageNet Classification with Deep C 1b0f01074320435c8e31aa28118c2a1c.html#results",
    "title": "[Paper Review] ImageNet Classification with Deep Convolutional Neural Networks (2012)",
    "section": "",
    "text": "Learning rate was kept constant and manually adjusted by seeing the validation error rate.\nThe network won the ILSCVRC-2010 with top-1 and top-5test set error rates of 37.5% and 17.0%5."
  },
  {
    "objectID": "posts/[Paper Review] ImageNet Classification with Deep C 1b0f01074320435c8e31aa28118c2a1c.html#future-scope",
    "href": "posts/[Paper Review] ImageNet Classification with Deep C 1b0f01074320435c8e31aa28118c2a1c.html#future-scope",
    "title": "[Paper Review] ImageNet Classification with Deep Convolutional Neural Networks (2012)",
    "section": "",
    "text": "Use of unsupervised learning to find patterns in data could potentially help. Like setting weights based on it and then tuning it by supervised learning has the potential to increase the accuracy. Further doing this task on video sequences it can see how data evolves and can help in identifying features even better."
  },
  {
    "objectID": "posts/JPEG.html",
    "href": "posts/JPEG.html",
    "title": "JPEG",
    "section": "",
    "text": "We will explore JPEG Compression in this Blog. First we create a synthetic image of size 256*256 and we will compress it using the JPEG Algorithm.\nfrom PIL import Image, ImageDraw\nimport matplotlib.pyplot as plt\nwidth, height = 256, 256\nimage = Image.new(\"RGB\", (width, height))\ndraw = ImageDraw.Draw(image)\ndraw.rectangle([50, 50, 200, 200], fill=(255, 0, 0))\ndraw.ellipse([100, 100, 150, 150], fill=(0, 255, 0))\nimage.save(\"synthetic_image.jpg\")\nplt.imshow(image)\n\n&lt;matplotlib.image.AxesImage at 0x7b93372eccd0&gt;\nHuman eyes are more sensitive to brightness than color (Since we have more rods as compared to cones in our retina). So to achieve compression with minimal loss in percieved vision quality, we will keep the data in the intensity domain as it is and compress the data in colour domain. The intensity domain is formally called the luminosity(Y) and the colour domains are (Cb and Cr). We will first convert the image from RGB channels to YCbCr channels.\nimport numpy as np\nfrom PIL import Image\nimport matplotlib.pyplot as plt\nimport cv2\n\n\ndef rgb_to_ycbcr(rgb_image):\n    rgb_array = np.array(rgb_image)\n    print(rgb_array.shape)\n    ycbcr_array = np.zeros(rgb_array.shape, dtype=rgb_array.dtype)\n    ycbcr_array[:, :, 0] = 0.299 * rgb_array[:, :, 0] + \\\n        0.587 * rgb_array[:, :, 1] + 0.114 * rgb_array[:, :, 2]\n    ycbcr_array[:, :, 1] = -0.169 * rgb_array[:, :, 0] - \\\n        0.331 * rgb_array[:, :, 1] + 0.500 * rgb_array[:, :, 2]\n    ycbcr_array[:, :, 2] = 0.500 * rgb_array[:, :, 0] - \\\n        0.419 * rgb_array[:, :, 1] - 0.081 * rgb_array[:, :, 2]\n    ycbcr_array = np.clip(ycbcr_array, 0, 255).astype(np.uint8)\n\n    return ycbcr_array\n\n\nrgb_image = Image.open(\"synthetic_image.jpg\")\n\nycbcr_array = rgb_to_ycbcr(rgb_image)\n# # plt.imshow(ycbcr_array)\n# # plt.show()\n# ycbcr_to_rgb = cv2.cvtColor(ycbcr_array, cv2.COLOR_YCrCb2RGB)\n\n# plt.imshow(ycbcr_to_rgb)\n# plt.show()\n# Create subplots for Y, Cb, Cr, and Combined Image\nplt.figure(figsize=(16, 4))\n\n# Y Channel\nplt.subplot(141)\nplt.imshow(ycbcr_array[:, :, 0])\nplt.title('Y Channel')\nplt.axis('off')\n\n# Cb Channel\nplt.subplot(142)\nplt.imshow(ycbcr_array[:, :, 1])\nplt.title('Cb Channel')\nplt.axis('off')\n\n# Cr Channel\nplt.subplot(143)\nplt.imshow(ycbcr_array[:, :, 2])\nplt.title('Cr Channel')\nplt.axis('off')\n\n# Combined YCbCr Image\nplt.subplot(144)\nplt.imshow(ycbcr_array)\nplt.title('Combined YCbCr Image')\nplt.axis('off')\n\nplt.show()\n\n(256, 256, 3)\nInterestingly it is observed there are some artifacts at the edges of the square. This is due to Cb and Cr channels\n# ycbcr_image = Image.open(\"ycbcr_image.jpg\")\n# image_array = np.array(ycbcr_image)\n# print(image_array.shape)\ny = ycbcr_array[:, :, 0]\ncb = ycbcr_array[:, :, 1]\ncr = ycbcr_array[:, :, 2]\n# #try using opencv\nheight, width = cb.shape"
  },
  {
    "objectID": "posts/JPEG.html#chroma-subsampling",
    "href": "posts/JPEG.html#chroma-subsampling",
    "title": "JPEG",
    "section": "Chroma Subsampling",
    "text": "Chroma Subsampling\nChroma subsampling involves reducing the resolution of the chrominance channels while keeping the luminance channel at full resolution\n\n4:2:0 Chroma Subsampling: Both horizontal and vertical subsampling is applied. For every two pixels in both the horizontal and vertical directions, there is one chrominance value.\n\nWe will basically take 2x2 matrix from the image channels Cb and Cr, take their average and represent it using a single pixel.\n\ndownsampled_cb = np.zeros((height // 2, width // 2))\ndownsampled_cr = np.zeros((height // 2, width // 2))\nfor i in range(0, height, 2):\n    for j in range(0, width, 2):\n        cb_avg = np.mean(cb[i:i+2, j:j+2])\n        cr_avg = np.mean(cr[i:i+2, j:j+2])\n        downsampled_cb[i // 2, j // 2] = cb_avg\n        downsampled_cr[i // 2, j // 2] = cr_avg\nupsampled_cb = np.zeros((height, width))\nupsampled_cr = np.zeros((height, width))\nfor i in range(0, height, 2):\n    for j in range(0, width, 2):\n        upsampled_cb[i:i+2, j:j+2] = downsampled_cb[i // 2, j // 2]\n        upsampled_cr[i:i+2, j:j+2] = downsampled_cr[i // 2, j // 2]\nc_ycbcr_image = np.stack((y, upsampled_cb, upsampled_cr), axis=-1)\nprint(c_ycbcr_image.shape)\n# plt.imshow(c_ycbcr_image)\n# plt.title('c_YCbCr Image')\n# plt.axis('off')\n# plt.show()\n\nplt.figure(figsize=(16, 4))\n\n# Y Channel\nplt.subplot(141)\nplt.imshow(c_ycbcr_image[:, :, 0])\nplt.title('Y Channel')\nplt.axis('off')\n\n# Cb Channel\nplt.subplot(142)\nplt.imshow(c_ycbcr_image[:, :, 1])\nplt.title('Cb Channel')\nplt.axis('off')\n\n# Cr Channel\nplt.subplot(143)\nplt.imshow(c_ycbcr_image[:, :, 2])\nplt.title('Cr Channel')\nplt.axis('off')\n\n# Combined YCbCr Image\nplt.subplot(144)\nplt.imshow(c_ycbcr_image)\nplt.title('Combined subsampled_YCbCr Image')\nplt.axis('off')\n\nplt.show()\n\nWARNING:matplotlib.image:Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\n\n\n(256, 256, 3)\n\n\n\n\n\n##DCT DCT or Discrete Cosine Transform works on a principle similar to the fourier transform. It breaks down frequencies as a sum of cosine functions. We calculate dct coefficients for 8x8 matrices which are then represented as a weighted sum of the components.\n\nfrom scipy.fftpack import dct, idct\n\nimage = c_ycbcr_image-128\nblock_size = 8\ndct_coefficients = np.zeros_like(image, dtype=np.float32)\nfor i in range(0, 256, block_size):\n    for j in range(0, 256, block_size):\n        block = image[i:i+block_size, j:j+block_size]\n        dct_block = dct(dct(block, axis=0, norm='ortho'), axis=1, norm='ortho')\n        dct_coefficients[i:i+block_size, j:j+block_size] = dct_block\n\n# Inverse DCT to recover the original image\nreconstructed_image = np.zeros_like(image, dtype=np.uint8)\n\nfor i in range(0, 256, block_size):\n    for j in range(0, 256, block_size):\n        dct_block = dct_coefficients[i:i+block_size, j:j+block_size]\n        block = idct(idct(dct_block, axis=0, norm='ortho'),\n                     axis=1, norm='ortho')\n        reconstructed_image[i:i+block_size, j:j+block_size] = np.round(block)\n\n# Display the original and reconstructed images\nplt.subplot(121)\nplt.imshow(c_ycbcr_image, cmap='gray', interpolation='nearest')\nplt.title('Subsampled_Ycbcr')\n\nplt.subplot(122)\nplt.imshow(reconstructed_image, cmap='gray', interpolation='nearest')\nplt.title('Reconstructed Image')\n\nplt.show()\n# see open cv output too\n\nWARNING:matplotlib.image:Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\n\n\n\n\n\nAn interesting observation is that the reconstructed image after taking dct and then idct we see the appearance of the ellipse drawn in the original image which was lost after chroma subsampling. This tells us that it does not mean if we cant see something its not there but the information might be still contained.\n\nnormalized_dct = dct_coefficients\nprint(normalized_dct.shape)\n\n(256, 256, 3)\n\n\n\nQuantization Tables\nIn this code, two quantization tables are defined: QTy for the luminance (Y) channel and QTC for the chrominance (Cb and Cr) channels. These tables play a fundamental role in quantization by specifying the values by which the DCT (Discrete Cosine Transform) coefficients are divided to achieve compression.\nThe luminance quantization table (QTy) and chrominance quantization table (QTC) contain specific values that determine the trade-off between image quality and compression ratio. Higher values in these tables lead to more aggressive quantization and higher compression, but at the cost of reduced image quality.\n\n\nBlock-Based Quantization\nThe code demonstrates block-based quantization for the Y, Cb, and Cr channels separately. The code iterates through the image in 8x8 blocks, applies quantization to each block based on the corresponding quantization table, and stores the quantized values in separate arrays (quantized_y, quantized_cb, and quantized_cr).\n\n\nCounting Non-Zero Values\nThe code concludes by using np.count_nonzero() to count the number of non-zero values in the quantized image (quantised). This count represents the number of coefficients that were quantized to a non-zero value during compression, and it can provide insights into the level of compression achieved.\n\nQTy = np.array([[16, 11, 10, 16, 24, 40, 51, 61],  # luminance quantization table\n                [12, 12, 14, 19, 26, 48, 60, 55],\n                [14, 13, 16, 24, 40, 57, 69, 56],\n                [14, 17, 22, 29, 51, 87, 80, 62],\n                [18, 22, 37, 56, 68, 109, 103, 77],\n                [24, 35, 55, 64, 81, 104, 113, 92],\n                [49, 64, 78, 87, 103, 121, 120, 101],\n                [72, 92, 95, 98, 112, 100, 103, 99]])\n\nQTC = np.array([[17, 18, 24, 47, 99, 99, 99, 99],  # chrominance quantization table\n                [18, 21, 26, 66, 99, 99, 99, 99],\n                [24, 26, 56, 99, 99, 99, 99, 99],\n                [47, 66, 99, 99, 99, 99, 99, 99],\n                [99, 99, 99, 99, 99, 99, 99, 99],\n                [99, 99, 99, 99, 99, 99, 99, 99],\n                [99, 99, 99, 99, 99, 99, 99, 99],\n                [99, 99, 99, 99, 99, 99, 99, 99]])\n\nblock_size = 8\n\ny_channel = dct_coefficients[:, :, 0]\ncb_channel = dct_coefficients[:, :, 1]\ncr_channel = dct_coefficients[:, :, 2]\nquantized_y = np.zeros_like(y_channel, dtype=np.float32)\nquantized_cb = np.zeros_like(cb_channel, dtype=np.float32)\nquantized_cr = np.zeros_like(cr_channel, dtype=np.float32)\n\nfor i in range(0, 256, block_size):\n    for j in range(0, 256, block_size):\n        y_block = y_channel[i:i+block_size, j:j+block_size]\n        cb_block = cb_channel[i:i+block_size, j:j+block_size]\n        cr_block = cr_channel[i:i+block_size, j:j+block_size]\n\n        quantized_y_block = np.round(y_block / QTy)\n        quantized_cb_block = np.round(cb_block / QTC)\n        quantized_cr_block = np.round(cr_block / QTC)\n\n        quantized_y[i:i+block_size, j:j+block_size] = quantized_y_block\n        quantized_cb[i:i+block_size, j:j+block_size] = quantized_cb_block\n        quantized_cr[i:i+block_size, j:j+block_size] = quantized_cr_block\nquantised = np.stack((y, quantized_cb, quantized_cr), axis=-1)\nprint(np.count_nonzero(quantised))\n\n28330\n\n\nFrom 196,608 non zero values it is down to 28330 non zero values which will be further reduced in size using huffman encoding"
  },
  {
    "objectID": "posts/change_of_variables.html",
    "href": "posts/change_of_variables.html",
    "title": "Change of Variables with Jacobian Matrix",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef linear_transformation(x, y):\n    u = 2*x + y\n    v = x - y\n    return u, v\n\n\nx_range = np.linspace(-5, 5, 100)\ny_range = np.linspace(-5, 5, 100)\nx, y = np.meshgrid(x_range, y_range)\nu, v = linear_transformation(x, y)\n# Jacobian matrix for the linear transformation\nJacobian = np.array([[2, 1],\n                     [1, -1]])\nplt.figure(figsize=(10, 5))\n# Original grid\nplt.subplot(1, 2, 1)\nplt.title(\"Original Grid (x, y)\")\nplt.quiver(x, y, np.ones_like(x), np.zeros_like(y), scale=10, scale_units='xy')\nplt.xlim(-5, 5)\nplt.ylim(-5, 5)\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\n\n# Transformed grid\nplt.subplot(1, 2, 2)\nplt.title(\"Transformed Grid (u, v)\")\nplt.quiver(u, v, np.ones_like(u), np.zeros_like(v), scale=10, scale_units='xy')\nplt.xlim(-10, 10)\nplt.ylim(-10, 10)\nplt.xlabel(\"u\")\nplt.ylabel(\"v\")\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef nonlinear_transformation(x, y):\n    u = x\n    v = 6 * y  # Scale the y-coordinate by a factor of 6\n    return u, v\n\n\nx_range = np.linspace(-5, 5, 1000)\ny_range = np.linspace(-5, 5, 1000)\nx, y = np.meshgrid(x_range, y_range)\nu, v = nonlinear_transformation(x, y)\n\nplt.figure(figsize=(10, 5))\n# Original grid\nplt.subplot(1, 2, 1)\nplt.title(\"Original Grid (x, y)\")\n# Plot the original ellipse with the correct contour level\nplt.contour(x, y, x**2 + (y/6)**2, levels=[1], colors='b')\nplt.xlim(-5, 5)\nplt.ylim(-50, 50)  # Adjust the y-coordinate range\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\n\n# Transformed grid\nplt.subplot(1, 2, 2)\nplt.title(\"Transformed Grid (u, v)\")\n# Plot the transformed circle\nplt.contour(u, v, u**2 + v**2, levels=[1], colors='r')\nplt.xlim(-10, 10)\nplt.ylim(-10, 10)  # Adjust the y-coordinate range for visualization\nplt.xlabel(\"u\")\nplt.ylabel(\"v\")\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define ellipse equation: x^2 + y^2 / 36 = 1\na = 6  # Semi-major axis length\nb = 6  # Semi-minor axis length\n\n# Generate grid\nx = np.linspace(-10, 10, 200)\ny = np.linspace(-10, 10, 200)\nX, Y = np.meshgrid(x, y)\n\n# Define ellipse equation\nellipse = X**2 + Y**2 / b**2 - 1\n\n# Define arrow properties\narrow_length = 0.5\narrow_color = 'gray'\narrow_alpha = 0.5\nnum_arrows = 20  # Number of arrows\n\n# Compute arrow positions\narrow_positions = np.linspace(0, len(x) - 1, num_arrows, dtype=int)\n\n# Apply transformation: u = x, v = 6*y\nU = X\nV = 6 * Y\n\n# Define transformed circle equation\ncircle = U**2 + V**2 - a**2\n\n# Define arrow directions (all pointing in a single direction)\n# Change this value to -1 to reverse the direction\narrow_direction = np.array([1])\n\n# First plot: Ellipse with uniform arrows\nplt.figure(figsize=(8, 8))\nplt.contour(X, Y, ellipse, levels=[1], colors='b',\n            linestyles='dashed', label='Ellipse')\nplt.quiver(X[arrow_positions[:, np.newaxis], arrow_positions], Y[arrow_positions[:, np.newaxis], arrow_positions],\n           arrow_direction, arrow_direction,\n           scale=10, pivot='mid', color=arrow_color, alpha=arrow_alpha, label='Arrows')\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.title('Ellipse with Uniform Arrows')\nplt.legend()\nplt.axis('equal')\nplt.grid(True)\nplt.show()\n\n# Second plot: Transformed Circle with uniform arrows\nplt.figure(figsize=(8, 8))\nplt.contour(U, V, circle, levels=[1], colors='r',\n            linestyles='solid', label='Circle')\nplt.quiver(U[arrow_positions[:, np.newaxis], arrow_positions], V[arrow_positions[:, np.newaxis], arrow_positions],\n           arrow_direction, arrow_direction,\n           scale=10, pivot='mid', color=arrow_color, alpha=arrow_alpha, label='Arrows')\nplt.xlabel('U')\nplt.ylabel('V')\nplt.title('Transformed Circle with Uniform Arrows')\nplt.legend()\nplt.axis('equal')\nplt.grid(True)\nplt.show()\n\nC:\\Users\\asus\\AppData\\Local\\Temp\\ipykernel_14680\\3513024967.py:37: UserWarning: The following kwargs were not used by contour: 'label'\n  plt.contour(X, Y, ellipse, levels=[1], colors='b', linestyles='dashed', label='Ellipse')\nC:\\Users\\asus\\AppData\\Local\\Temp\\ipykernel_14680\\3513024967.py:51: UserWarning: The following kwargs were not used by contour: 'label'\n  plt.contour(U, V, circle, levels=[1], colors='r', linestyles='solid', label='Circle')\n\n\n\n\n\n\n\n\nThe above plots demonstrate how the grid changes and figures are transformed after changing variables using the jacobian. Next we see how transforming each unit rectangle using eulers method actually gives us the area of the ellipse that is piab. This is an example case of how jacobian determinant can help us transform figures to more workable ones to find area easily\n\nimport numpy as np\n\nb = 6\n\nx = np.linspace(-10, 10, 200)\ny = np.linspace(-10, 10, 200)\nX, Y = np.meshgrid(x, y)\n\nellipse = X**2 + Y**2 / b**2 - 1\n\nU = X\nV = 6 * Y\njacobian_det = 6\ncircle = U**2 + V**2 - 1\n\ndx = x[1] - x[0]\ndy = y[1] - y[0]\nellipse_area = 0.0\n\nfor i in range(len(x)-1):\n    for j in range(len(y)-1):\n        if ellipse[i, j] &lt;= 0:\n            ellipse_area += dx * dy\n\nprint(\"Approximated area of the ellipse using Euler's method: {:.2f}\".format(\n    ellipse_area))\n\ncircle_area = 0.0\n\nfor i in range(len(x) - 1):\n    for j in range(len(y) - 1):\n        if circle[i, j] &lt;= 0:\n            circle_area += dx * dy*jacobian_det  # to transform dx dy to du dv\n\nprint(\"Approximated area of the circle in the transformed domain: {:.2f}\".format(\n    circle_area))\n\nApproximated area of the ellipse using Euler's method: 18.95\nApproximated area of the circle in the transformed domain: 3.15\n\n\nWe see that the area of circle comes out to be nearly pi, when we will multiply this by jacobian determinat to the final area of ellipse, we will get pi16 = 6pi, which is the area of ellipse. Therefore we saw how integration will work when two integrals are present and we simplify using jacobian determinant. Int(int(complex function))=int(int(transformed function))*jacobian determinant"
  },
  {
    "objectID": "posts/change_of_variables.html#its-importance",
    "href": "posts/change_of_variables.html#its-importance",
    "title": "Change of Variables with Jacobian Matrix",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef linear_transformation(x, y):\n    u = 2*x + y\n    v = x - y\n    return u, v\n\n\nx_range = np.linspace(-5, 5, 100)\ny_range = np.linspace(-5, 5, 100)\nx, y = np.meshgrid(x_range, y_range)\nu, v = linear_transformation(x, y)\n# Jacobian matrix for the linear transformation\nJacobian = np.array([[2, 1],\n                     [1, -1]])\nplt.figure(figsize=(10, 5))\n# Original grid\nplt.subplot(1, 2, 1)\nplt.title(\"Original Grid (x, y)\")\nplt.quiver(x, y, np.ones_like(x), np.zeros_like(y), scale=10, scale_units='xy')\nplt.xlim(-5, 5)\nplt.ylim(-5, 5)\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\n\n# Transformed grid\nplt.subplot(1, 2, 2)\nplt.title(\"Transformed Grid (u, v)\")\nplt.quiver(u, v, np.ones_like(u), np.zeros_like(v), scale=10, scale_units='xy')\nplt.xlim(-10, 10)\nplt.ylim(-10, 10)\nplt.xlabel(\"u\")\nplt.ylabel(\"v\")\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef nonlinear_transformation(x, y):\n    u = x\n    v = 6 * y  # Scale the y-coordinate by a factor of 6\n    return u, v\n\n\nx_range = np.linspace(-5, 5, 1000)\ny_range = np.linspace(-5, 5, 1000)\nx, y = np.meshgrid(x_range, y_range)\nu, v = nonlinear_transformation(x, y)\n\nplt.figure(figsize=(10, 5))\n# Original grid\nplt.subplot(1, 2, 1)\nplt.title(\"Original Grid (x, y)\")\n# Plot the original ellipse with the correct contour level\nplt.contour(x, y, x**2 + (y/6)**2, levels=[1], colors='b')\nplt.xlim(-5, 5)\nplt.ylim(-50, 50)  # Adjust the y-coordinate range\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\n\n# Transformed grid\nplt.subplot(1, 2, 2)\nplt.title(\"Transformed Grid (u, v)\")\n# Plot the transformed circle\nplt.contour(u, v, u**2 + v**2, levels=[1], colors='r')\nplt.xlim(-10, 10)\nplt.ylim(-10, 10)  # Adjust the y-coordinate range for visualization\nplt.xlabel(\"u\")\nplt.ylabel(\"v\")\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define ellipse equation: x^2 + y^2 / 36 = 1\na = 6  # Semi-major axis length\nb = 6  # Semi-minor axis length\n\n# Generate grid\nx = np.linspace(-10, 10, 200)\ny = np.linspace(-10, 10, 200)\nX, Y = np.meshgrid(x, y)\n\n# Define ellipse equation\nellipse = X**2 + Y**2 / b**2 - 1\n\n# Define arrow properties\narrow_length = 0.5\narrow_color = 'gray'\narrow_alpha = 0.5\nnum_arrows = 20  # Number of arrows\n\n# Compute arrow positions\narrow_positions = np.linspace(0, len(x) - 1, num_arrows, dtype=int)\n\n# Apply transformation: u = x, v = 6*y\nU = X\nV = 6 * Y\n\n# Define transformed circle equation\ncircle = U**2 + V**2 - a**2\n\n# Define arrow directions (all pointing in a single direction)\n# Change this value to -1 to reverse the direction\narrow_direction = np.array([1])\n\n# First plot: Ellipse with uniform arrows\nplt.figure(figsize=(8, 8))\nplt.contour(X, Y, ellipse, levels=[1], colors='b',\n            linestyles='dashed', label='Ellipse')\nplt.quiver(X[arrow_positions[:, np.newaxis], arrow_positions], Y[arrow_positions[:, np.newaxis], arrow_positions],\n           arrow_direction, arrow_direction,\n           scale=10, pivot='mid', color=arrow_color, alpha=arrow_alpha, label='Arrows')\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.title('Ellipse with Uniform Arrows')\nplt.legend()\nplt.axis('equal')\nplt.grid(True)\nplt.show()\n\n# Second plot: Transformed Circle with uniform arrows\nplt.figure(figsize=(8, 8))\nplt.contour(U, V, circle, levels=[1], colors='r',\n            linestyles='solid', label='Circle')\nplt.quiver(U[arrow_positions[:, np.newaxis], arrow_positions], V[arrow_positions[:, np.newaxis], arrow_positions],\n           arrow_direction, arrow_direction,\n           scale=10, pivot='mid', color=arrow_color, alpha=arrow_alpha, label='Arrows')\nplt.xlabel('U')\nplt.ylabel('V')\nplt.title('Transformed Circle with Uniform Arrows')\nplt.legend()\nplt.axis('equal')\nplt.grid(True)\nplt.show()\n\nC:\\Users\\asus\\AppData\\Local\\Temp\\ipykernel_14680\\3513024967.py:37: UserWarning: The following kwargs were not used by contour: 'label'\n  plt.contour(X, Y, ellipse, levels=[1], colors='b', linestyles='dashed', label='Ellipse')\nC:\\Users\\asus\\AppData\\Local\\Temp\\ipykernel_14680\\3513024967.py:51: UserWarning: The following kwargs were not used by contour: 'label'\n  plt.contour(U, V, circle, levels=[1], colors='r', linestyles='solid', label='Circle')\n\n\n\n\n\n\n\n\nThe above plots demonstrate how the grid changes and figures are transformed after changing variables using the jacobian. Next we see how transforming each unit rectangle using eulers method actually gives us the area of the ellipse that is piab. This is an example case of how jacobian determinant can help us transform figures to more workable ones to find area easily\n\nimport numpy as np\n\nb = 6\n\nx = np.linspace(-10, 10, 200)\ny = np.linspace(-10, 10, 200)\nX, Y = np.meshgrid(x, y)\n\nellipse = X**2 + Y**2 / b**2 - 1\n\nU = X\nV = 6 * Y\njacobian_det = 6\ncircle = U**2 + V**2 - 1\n\ndx = x[1] - x[0]\ndy = y[1] - y[0]\nellipse_area = 0.0\n\nfor i in range(len(x)-1):\n    for j in range(len(y)-1):\n        if ellipse[i, j] &lt;= 0:\n            ellipse_area += dx * dy\n\nprint(\"Approximated area of the ellipse using Euler's method: {:.2f}\".format(\n    ellipse_area))\n\ncircle_area = 0.0\n\nfor i in range(len(x) - 1):\n    for j in range(len(y) - 1):\n        if circle[i, j] &lt;= 0:\n            circle_area += dx * dy*jacobian_det  # to transform dx dy to du dv\n\nprint(\"Approximated area of the circle in the transformed domain: {:.2f}\".format(\n    circle_area))\n\nApproximated area of the ellipse using Euler's method: 18.95\nApproximated area of the circle in the transformed domain: 3.15\n\n\nWe see that the area of circle comes out to be nearly pi, when we will multiply this by jacobian determinat to the final area of ellipse, we will get pi16 = 6pi, which is the area of ellipse. Therefore we saw how integration will work when two integrals are present and we simplify using jacobian determinant. Int(int(complex function))=int(int(transformed function))*jacobian determinant"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blogs",
    "section": "",
    "text": "Jigsaw based Self Supervised Learning on CIFAR-10\n\n\n\n\n\n\n\n\n\n\n\n\nJan 10, 2024\n\n\nShreyans Jain\n\n\n\n\n\n\n  \n\n\n\n\nFisher Information\n\n\n\n\n\n\n\n\n\n\n\n\nOct 19, 2023\n\n\nShreyans Jain\n\n\n\n\n\n\n  \n\n\n\n\nChange of Variables with Jacobian Matrix\n\n\n\n\n\n\n\n\n\n\n\n\nOct 18, 2023\n\n\nShreyans Jain\n\n\n\n\n\n\n  \n\n\n\n\nJPEG\n\n\n\n\n\n\n\n\n\n\n\n\nSep 12, 2023\n\n\nShreyans Jain\n\n\n\n\n\n\n  \n\n\n\n\n[Paper Review] ImageNet Classification with Deep Convolutional Neural Networks (2012)\n\n\n\n\n\n\n\n\n\n\n\n\nJun 23, 2023\n\n\nShreyans Jain\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/fisher_info.html",
    "href": "posts/fisher_info.html",
    "title": "Fisher Information",
    "section": "",
    "text": "Fisher Information\nUsed to find out how much information a particular random variable has about an unknown parameter. Example: If we have a coin and we want to know if it is fair or not, we can toss it 100 times and count the number of heads. If we get 100 heads, we can be pretty sure that the coin is not fair. If we get 50 heads, we can’t be sure. If we get 0 heads, we can be pretty sure that the coin is not fair. So, the number of heads gives us information about the fairness of the coin. The Fisher information is a measure of how much information a random variable has about an unknown parameter.\nThe math: Its defined as the variance of the score of log likelihood of a random variable. But the the partial derivative of the log-likelihood behaves similarly to a random variable, just like y. It possesses both a mean and a variance.\nWhen the variance of this derivative is smaller, there is a higher probability that the observed value y will closely match the true mean of the probability distribution of y. In simpler terms, more information about the true mean of y is embedded within the random variable y itself. Conversely, when the variance of the partial derivative of ℓ(λ | y=y) is greater, the information contained in y about its true mean diminishes.\nThe relationship between the information embedded in ‘y’ regarding the genuine value of a parameter θ, drawn from the assumed distribution of ‘y,’ is inversely proportional to the variance of the partial derivative concerning θ in the log-likelihood function.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nrange_min = -10\nrange_max = 10\nnum_points = 20\n\nx_values = np.linspace(range_min, range_max, num_points)\n\nvariance1 = 10\nvariance2 = 25\n\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))\n\n\nfor i, x in enumerate(x_values):\n    log_likelihood1 = -0.5 * \\\n        np.log(2 * np.pi * variance1) - ((x - x_values) ** 2) / (2 * variance1)\n    log_likelihood2 = -0.5 * \\\n        np.log(2 * np.pi * variance2) - ((x - x_values) ** 2) / (2 * variance2)\n    score1 = (x - x_values) / variance1\n    score2 = (x - x_values) / variance2\n\n    ax1.plot(x_values, log_likelihood1, label=f\"Observation Point {i+1}\")\n    ax2.plot(x_values, log_likelihood2, label=f\"Observation Point {i+1}\")\n    ax3.plot(x_values, score1, label=f\"Observation Point {i+1}\")\n    ax4.plot(x_values, score2, label=f\"Observation Point {i+1}\")\n\nax1.set_xlabel(\"Observation\")\nax1.set_ylabel(\"Log-Likelihood\")\nax1.set_title(f\"Log-Likelihood for Variance {variance1}\")\nax1.grid()\nax1.set_ylim([-10, 0])  # set y-limits\n\nax2.set_xlabel(\"Observation\")\nax2.set_ylabel(\"Log-Likelihood\")\nax2.set_title(f\"Log-Likelihood for Variance {variance2}\")\nax2.grid()\nax2.set_ylim([-10, 0])  # set y-limits\n\nax3.set_xlabel(\"Observation\")\nax3.set_ylabel(\"Score\")\nax3.set_title(f\"Score for Variance {variance1}\")\nax3.grid()\nax3.set_ylim([-3, 4])\nax4.set_xlabel(\"Observation\")\nax4.set_ylabel(\"Score\")\nax4.set_title(f\"Score for Variance {variance2}\")\nax4.grid()\nax4.set_ylim([-3, 4])\n\nplt.show()\n\n\n\n\nWe see that in the case of less variance the score matrix is more varied and hence contains more information about the true mean. We can also see from the log likliehood graphs that a lower variance is showing us that most points in our sample peak at zero indicating its the true mean wheareas a higher variance does not easily tell us where the peak us.\nTo make it more intuitive, in our previous example if we can crudely say that when the results follow a ‘pattern’ and the results are less varied we actually have more information about the biasing."
  },
  {
    "objectID": "posts/ssl.html",
    "href": "posts/ssl.html",
    "title": "Jigsaw based Self Supervised Learning on CIFAR-10",
    "section": "",
    "text": "Initially we train EfficientNet model on 5% of the data and then test it on 50% of the test data. Then we create the jigsaw pre training dataset on 45% of the images. Then the pretrained model is fine tuned on the 5% of images and tested on 50% of the data. Additional experiments like using pretrained weights for EfficientNet and varying hyperparameters have been carried out.\n\n\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nfrom torch.utils.data import DataLoader, Dataset, random_split\nfrom torchvision.transforms import ToTensor, Resize, Compose\nfrom torchvision.utils import save_image\nfrom PIL import Image\nimport os\nfrom glob import glob\nimport cv2\nimport numpy as np\nimport torchvision.transforms as transforms\nimport matplotlib.pyplot as plt\nfrom torchvision.datasets import ImageFolder\nimport os\nimport time\n\nPreparing DataLoaders\n\nfrom torchvision.datasets import CIFAR10\ntransform = Compose([\n    # Resize images to 33x33 to make it divisible by 3 for the later jigsaw task.\n    Resize((33, 33)),\n    ToTensor()\n])\n# Load CIFAR-10 dataset\ndataset = CIFAR10(root='./data', train=True, download=True,\n                  transform=transform)\n\n# Split dataset\ntrain_size = int(0.05 * len(dataset))\npretrain_size = int(0.45 * len(dataset))\ntest_size = len(dataset) - train_size - pretrain_size\ntrain_dataset, pretrain_dataset, test_dataset = random_split(\n    dataset, [train_size, pretrain_size, test_size])\n\n# Create data loaders\ntrain_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)\npretrain_loader = DataLoader(pretrain_dataset, batch_size=32, shuffle=True)\ntest_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)\n\nFiles already downloaded and verified\n\n\n\n\n\n\nInitially using the efficient net model without pretraining.\n\nfrom torchvision import models\nmodel = models.efficientnet_b0(pretrained=False)\nnum_ftrs = model.classifier[1].in_features\nmodel.classifier[1] = nn.Linear(num_ftrs, 10)\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nmodel = model.to(device)\n\n/usr/lib/python3/dist-packages/torchvision/models/_utils.py:208: UserWarning: The parameter 'pretrained' is deprecated since 0.13 and may be removed in the future, please use 'weights' instead.\n  warnings.warn(\n/usr/lib/python3/dist-packages/torchvision/models/_utils.py:223: UserWarning: Arguments other than a weight enum or `None` for 'weights' are deprecated since 0.13 and may be removed in the future. The current behavior is equivalent to passing `weights=None`.\n  warnings.warn(msg)\n\n\n\n# Loss function and optimizer\ncriterion = nn.CrossEntropyLoss()\noptimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.9)\nscheduler = optim.lr_scheduler.StepLR(optimizer, step_size=7, gamma=0.1)\n\n\n# train on only 5% of the data\nloss_list = []\nlr = []\n\n\nfor epoch in range(25):  # loop over the dataset multiple times\n    scheduler.step()\n    running_loss = 0.0\n    for i, data in enumerate(train_loader, 0):\n        inputs, targets = data\n        inputs = inputs.to(device)\n        targets = targets.to(device)\n        optimizer.zero_grad()\n        outputs = model(inputs)\n        loss = criterion(outputs, targets)\n        loss.backward()\n        optimizer.step()\n\n        lr.append(scheduler.get_lr()[0])\n\n        running_loss += loss.item()\n\n        if i % 10 == 9:    # print every 10 mini-batches\n\n            print('[%d, %5d] loss: %.3f, lr: %.6f' %\n\n                  (epoch + 1, i + 1, running_loss / 10, scheduler.get_lr()[0]))\n            # append avg running loss every 10 epochs\n            loss_list.append(running_loss/10)\n            running_loss = 0.0\n\n\nplt.subplot(2, 1, 1)\nplt.plot(loss_list, label='Training Loss')\nplt.title('Training Loss over Batches')\nplt.xlabel('Batch')\nplt.ylabel('Loss')\nplt.legend()\n\nplt.subplot(2, 1, 2)\nplt.plot(lr, label='Learning Rate', color='r')\nplt.title('Learning Rate over Batches')\nplt.xlabel('Batch')\nplt.ylabel('Learning Rate')\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n# save the model state dict\ntorch.save(model.state_dict(),\n           './cifar10_5percent_scheduler_pretrained_false.pth')\n\nUsing a pretrained (on imagenet) efficienet model\n\nfrom torchvision import models\nmodel = models.efficientnet_b0(pretrained=True)\nnum_ftrs = model.classifier[1].in_features\nmodel.classifier[1] = nn.Linear(num_ftrs, 10)\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nmodel = model.to(device)\n# Loss function and optimizer\ncriterion = nn.CrossEntropyLoss()\noptimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.9)\nscheduler = optim.lr_scheduler.StepLR(optimizer, step_size=7, gamma=0.1)\n\n/usr/lib/python3/dist-packages/torchvision/models/_utils.py:223: UserWarning: Arguments other than a weight enum or `None` for 'weights' are deprecated since 0.13 and may be removed in the future. The current behavior is equivalent to passing `weights=EfficientNet_B0_Weights.IMAGENET1K_V1`. You can also use `weights=EfficientNet_B0_Weights.DEFAULT` to get the most up-to-date weights.\n  warnings.warn(msg)\nDownloading: \"https://download.pytorch.org/models/efficientnet_b0_rwightman-3dd342df.pth\" to /home/deus/.cache/torch/hub/checkpoints/efficientnet_b0_rwightman-3dd342df.pth\n100%|██████████| 20.5M/20.5M [00:01&lt;00:00, 14.2MB/s]\n\n\n\n# train on only 5% of the data\nloss_list = []\nlr = []\n\n\nfor epoch in range(25):  # loop over the dataset multiple times\n    scheduler.step()\n    running_loss = 0.0\n    for i, data in enumerate(train_loader, 0):\n        inputs, targets = data\n        inputs = inputs.to(device)\n        targets = targets.to(device)\n        optimizer.zero_grad()\n        outputs = model(inputs)\n        loss = criterion(outputs, targets)\n        loss.backward()\n        optimizer.step()\n        lr.append(scheduler.get_lr()[0])\n        running_loss += loss.item()\n\n        if i % 10 == 9:    # print every 10 mini-batches\n\n            print('[%d, %5d] loss: %.3f, lr: %.6f' %\n\n                  (epoch + 1, i + 1, running_loss / 10, scheduler.get_lr()[0]))\n            loss_list.append(running_loss/10)\n            running_loss = 0.0\n\n\nplt.subplot(2, 1, 1)\nplt.plot(loss_list, label='Training Loss')\nplt.title('Training Loss over Batches')\nplt.xlabel('Batch')\nplt.ylabel('Loss')\nplt.legend()\n\nplt.subplot(2, 1, 2)\nplt.plot(lr, label='Learning Rate', color='r')\nplt.title('Learning Rate over Batches')\nplt.xlabel('Batch')\nplt.ylabel('Learning Rate')\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n# save the model state dict\ntorch.save(model.state_dict(),\n           './cifar10_5percent_scheduler_pretrained_true.pth')\n\nUsing adam optimiser (an attempt at hyperparameter tuning\n\nfrom torchvision import models\nmodel = models.efficientnet_b0(pretrained=True)\nnum_ftrs = model.classifier[1].in_features\nmodel.classifier[1] = nn.Linear(num_ftrs, 10)\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nmodel = model.to(device)\n\n\nimport torch.optim as optim\n\n# Loss function and optimizer\ncriterion = nn.CrossEntropyLoss()\noptimizer = optim.Adam(model.parameters(), lr=0.01)  # Using Adam optimizer\nnum_epochs = 25\nloss_list = []\n\n\n# Training loop\nfor epoch in range(num_epochs):\n    running_loss = 0.0\n    for i, (inputs, targets) in enumerate(train_loader):\n        #         inputs = reassemble_patches(inputs, grid_size=3)\n\n        inputs, targets = inputs.to(device), targets.to(device)\n\n        # Forward pass\n        outputs = model(inputs)\n        loss = criterion(outputs, targets)\n\n        # Backward and optimize\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n\n        running_loss += loss.item()\n        if i % 10 == 9:  # print every 10 mini-batches\n            print('[%d, %5d] loss: %.3f' %\n                  (epoch + 1, i + 1, running_loss / 10))\n            loss_list.append(running_loss/10)\n            running_loss = 0.0\n\n\nplt.subplot(2, 1, 1)\nplt.plot(loss_list, label='Training Loss')\nplt.title('Training Loss over Batches')\nplt.xlabel('Batch')\nplt.ylabel('Loss')\nplt.legend()\n\nplt.subplot(2, 1, 2)\nplt.plot(lr, label='Learning Rate', color='r')\nplt.title('Learning Rate over Batches')\nplt.xlabel('Batch')\nplt.ylabel('Learning Rate')\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n# save the model state dict\ntorch.save(model.state_dict(), './cifar10_5percent_adam_pretrained_true.pth')"
  },
  {
    "objectID": "posts/ssl.html#self-supervised-learning-on-cifar10",
    "href": "posts/ssl.html#self-supervised-learning-on-cifar10",
    "title": "Jigsaw based Self Supervised Learning on CIFAR-10",
    "section": "",
    "text": "Initially we train EfficientNet model on 5% of the data and then test it on 50% of the test data. Then we create the jigsaw pre training dataset on 45% of the images. Then the pretrained model is fine tuned on the 5% of images and tested on 50% of the data. Additional experiments like using pretrained weights for EfficientNet and varying hyperparameters have been carried out.\n\n\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nfrom torch.utils.data import DataLoader, Dataset, random_split\nfrom torchvision.transforms import ToTensor, Resize, Compose\nfrom torchvision.utils import save_image\nfrom PIL import Image\nimport os\nfrom glob import glob\nimport cv2\nimport numpy as np\nimport torchvision.transforms as transforms\nimport matplotlib.pyplot as plt\nfrom torchvision.datasets import ImageFolder\nimport os\nimport time\n\nPreparing DataLoaders\n\nfrom torchvision.datasets import CIFAR10\ntransform = Compose([\n    # Resize images to 33x33 to make it divisible by 3 for the later jigsaw task.\n    Resize((33, 33)),\n    ToTensor()\n])\n# Load CIFAR-10 dataset\ndataset = CIFAR10(root='./data', train=True, download=True,\n                  transform=transform)\n\n# Split dataset\ntrain_size = int(0.05 * len(dataset))\npretrain_size = int(0.45 * len(dataset))\ntest_size = len(dataset) - train_size - pretrain_size\ntrain_dataset, pretrain_dataset, test_dataset = random_split(\n    dataset, [train_size, pretrain_size, test_size])\n\n# Create data loaders\ntrain_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)\npretrain_loader = DataLoader(pretrain_dataset, batch_size=32, shuffle=True)\ntest_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)\n\nFiles already downloaded and verified\n\n\n\n\n\n\nInitially using the efficient net model without pretraining.\n\nfrom torchvision import models\nmodel = models.efficientnet_b0(pretrained=False)\nnum_ftrs = model.classifier[1].in_features\nmodel.classifier[1] = nn.Linear(num_ftrs, 10)\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nmodel = model.to(device)\n\n/usr/lib/python3/dist-packages/torchvision/models/_utils.py:208: UserWarning: The parameter 'pretrained' is deprecated since 0.13 and may be removed in the future, please use 'weights' instead.\n  warnings.warn(\n/usr/lib/python3/dist-packages/torchvision/models/_utils.py:223: UserWarning: Arguments other than a weight enum or `None` for 'weights' are deprecated since 0.13 and may be removed in the future. The current behavior is equivalent to passing `weights=None`.\n  warnings.warn(msg)\n\n\n\n# Loss function and optimizer\ncriterion = nn.CrossEntropyLoss()\noptimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.9)\nscheduler = optim.lr_scheduler.StepLR(optimizer, step_size=7, gamma=0.1)\n\n\n# train on only 5% of the data\nloss_list = []\nlr = []\n\n\nfor epoch in range(25):  # loop over the dataset multiple times\n    scheduler.step()\n    running_loss = 0.0\n    for i, data in enumerate(train_loader, 0):\n        inputs, targets = data\n        inputs = inputs.to(device)\n        targets = targets.to(device)\n        optimizer.zero_grad()\n        outputs = model(inputs)\n        loss = criterion(outputs, targets)\n        loss.backward()\n        optimizer.step()\n\n        lr.append(scheduler.get_lr()[0])\n\n        running_loss += loss.item()\n\n        if i % 10 == 9:    # print every 10 mini-batches\n\n            print('[%d, %5d] loss: %.3f, lr: %.6f' %\n\n                  (epoch + 1, i + 1, running_loss / 10, scheduler.get_lr()[0]))\n            # append avg running loss every 10 epochs\n            loss_list.append(running_loss/10)\n            running_loss = 0.0\n\n\nplt.subplot(2, 1, 1)\nplt.plot(loss_list, label='Training Loss')\nplt.title('Training Loss over Batches')\nplt.xlabel('Batch')\nplt.ylabel('Loss')\nplt.legend()\n\nplt.subplot(2, 1, 2)\nplt.plot(lr, label='Learning Rate', color='r')\nplt.title('Learning Rate over Batches')\nplt.xlabel('Batch')\nplt.ylabel('Learning Rate')\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n# save the model state dict\ntorch.save(model.state_dict(),\n           './cifar10_5percent_scheduler_pretrained_false.pth')\n\nUsing a pretrained (on imagenet) efficienet model\n\nfrom torchvision import models\nmodel = models.efficientnet_b0(pretrained=True)\nnum_ftrs = model.classifier[1].in_features\nmodel.classifier[1] = nn.Linear(num_ftrs, 10)\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nmodel = model.to(device)\n# Loss function and optimizer\ncriterion = nn.CrossEntropyLoss()\noptimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.9)\nscheduler = optim.lr_scheduler.StepLR(optimizer, step_size=7, gamma=0.1)\n\n/usr/lib/python3/dist-packages/torchvision/models/_utils.py:223: UserWarning: Arguments other than a weight enum or `None` for 'weights' are deprecated since 0.13 and may be removed in the future. The current behavior is equivalent to passing `weights=EfficientNet_B0_Weights.IMAGENET1K_V1`. You can also use `weights=EfficientNet_B0_Weights.DEFAULT` to get the most up-to-date weights.\n  warnings.warn(msg)\nDownloading: \"https://download.pytorch.org/models/efficientnet_b0_rwightman-3dd342df.pth\" to /home/deus/.cache/torch/hub/checkpoints/efficientnet_b0_rwightman-3dd342df.pth\n100%|██████████| 20.5M/20.5M [00:01&lt;00:00, 14.2MB/s]\n\n\n\n# train on only 5% of the data\nloss_list = []\nlr = []\n\n\nfor epoch in range(25):  # loop over the dataset multiple times\n    scheduler.step()\n    running_loss = 0.0\n    for i, data in enumerate(train_loader, 0):\n        inputs, targets = data\n        inputs = inputs.to(device)\n        targets = targets.to(device)\n        optimizer.zero_grad()\n        outputs = model(inputs)\n        loss = criterion(outputs, targets)\n        loss.backward()\n        optimizer.step()\n        lr.append(scheduler.get_lr()[0])\n        running_loss += loss.item()\n\n        if i % 10 == 9:    # print every 10 mini-batches\n\n            print('[%d, %5d] loss: %.3f, lr: %.6f' %\n\n                  (epoch + 1, i + 1, running_loss / 10, scheduler.get_lr()[0]))\n            loss_list.append(running_loss/10)\n            running_loss = 0.0\n\n\nplt.subplot(2, 1, 1)\nplt.plot(loss_list, label='Training Loss')\nplt.title('Training Loss over Batches')\nplt.xlabel('Batch')\nplt.ylabel('Loss')\nplt.legend()\n\nplt.subplot(2, 1, 2)\nplt.plot(lr, label='Learning Rate', color='r')\nplt.title('Learning Rate over Batches')\nplt.xlabel('Batch')\nplt.ylabel('Learning Rate')\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n# save the model state dict\ntorch.save(model.state_dict(),\n           './cifar10_5percent_scheduler_pretrained_true.pth')\n\nUsing adam optimiser (an attempt at hyperparameter tuning\n\nfrom torchvision import models\nmodel = models.efficientnet_b0(pretrained=True)\nnum_ftrs = model.classifier[1].in_features\nmodel.classifier[1] = nn.Linear(num_ftrs, 10)\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nmodel = model.to(device)\n\n\nimport torch.optim as optim\n\n# Loss function and optimizer\ncriterion = nn.CrossEntropyLoss()\noptimizer = optim.Adam(model.parameters(), lr=0.01)  # Using Adam optimizer\nnum_epochs = 25\nloss_list = []\n\n\n# Training loop\nfor epoch in range(num_epochs):\n    running_loss = 0.0\n    for i, (inputs, targets) in enumerate(train_loader):\n        #         inputs = reassemble_patches(inputs, grid_size=3)\n\n        inputs, targets = inputs.to(device), targets.to(device)\n\n        # Forward pass\n        outputs = model(inputs)\n        loss = criterion(outputs, targets)\n\n        # Backward and optimize\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n\n        running_loss += loss.item()\n        if i % 10 == 9:  # print every 10 mini-batches\n            print('[%d, %5d] loss: %.3f' %\n                  (epoch + 1, i + 1, running_loss / 10))\n            loss_list.append(running_loss/10)\n            running_loss = 0.0\n\n\nplt.subplot(2, 1, 1)\nplt.plot(loss_list, label='Training Loss')\nplt.title('Training Loss over Batches')\nplt.xlabel('Batch')\nplt.ylabel('Loss')\nplt.legend()\n\nplt.subplot(2, 1, 2)\nplt.plot(lr, label='Learning Rate', color='r')\nplt.title('Learning Rate over Batches')\nplt.xlabel('Batch')\nplt.ylabel('Learning Rate')\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n# save the model state dict\ntorch.save(model.state_dict(), './cifar10_5percent_adam_pretrained_true.pth')"
  },
  {
    "objectID": "posts/ssl.html#image-jigsaw-puzzle-pretraining",
    "href": "posts/ssl.html#image-jigsaw-puzzle-pretraining",
    "title": "Jigsaw based Self Supervised Learning on CIFAR-10",
    "section": "Image Jigsaw Puzzle Pretraining",
    "text": "Image Jigsaw Puzzle Pretraining\n\n\nfrom itertools import permutations\nfrom torchvision.transforms import functional as F\n\n\ndef extract_patches(image, grid_size=3):\n    patch_size = image.size(1) // grid_size\n    patches = [F.crop(image, i, j, patch_size, patch_size)\n               for i in range(0, image.size(1), patch_size)\n               for j in range(0, image.size(2), patch_size)]\n    return patches\n\n\ndef apply_permutation(patches, perm):\n    return [patches[i] for i in perm]\n\n\n# Example permutation generation (100 permutations)\nnum_permutations = 100\nall_perms = np.array(list(permutations(range(9))))\nselected_perms = all_perms[np.random.choice(\n    len(all_perms), num_permutations, replace=False)]\n\n\nfrom torch.utils.data import Dataset\n\n\nclass JigsawPuzzleDataset(Dataset):\n    def __init__(self, dataset, permutations):\n        self.dataset = dataset\n        self.permutations = permutations\n\n    def __len__(self):\n        return len(self.dataset)\n\n    def __getitem__(self, idx):\n        image, _ = self.dataset[idx]\n        perm_idx = np.random.choice(len(self.permutations))\n        perm = self.permutations[perm_idx]\n        shuffled_patches = apply_permutation(extract_patches(image), perm)\n        # Convert list of patches to tensor\n        shuffled_image = torch.stack(shuffled_patches)\n        return shuffled_image, perm_idx\n\n\n# Example usage\npretrain_dataset = JigsawPuzzleDataset(pretrain_dataset, selected_perms)\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport torchvision.transforms as transforms\n\n\ndef visualize_jigsaw(original_image, permuted_patches, grid_size=3):\n    \"\"\"\n    Visualize the original and permuted image side by side.\n\n    Args:\n    original_image (Tensor): The original image tensor.\n    permuted_patches (Tensor): The permuted patches tensor.\n    grid_size (int): The size of the grid to divide the image into.\n    \"\"\"\n    # Convert tensors to numpy arrays\n    original_image = original_image.permute(1, 2, 0).numpy()\n\n    # Reconstruct permuted image from patches\n    patch_size = original_image.shape[0] // grid_size\n    permuted_image = permuted_patches.view(\n        grid_size, grid_size, 3, patch_size, patch_size)\n    permuted_image = permuted_image.permute(0, 3, 1, 4, 2).contiguous()\n    permuted_image = permuted_image.view(\n        grid_size * patch_size, grid_size * patch_size, 3)\n\n    # Plotting\n    fig, axes = plt.subplots(1, 2, figsize=(10, 5))\n    axes[0].imshow(original_image)\n    axes[0].set_title(\"Original Image\")\n    axes[0].axis('off')\n\n    axes[1].imshow(permuted_image)\n    axes[1].set_title(\"Permuted Image\")\n    axes[1].axis('off')\n\n    plt.show()\n\n\n# Example usage\n# Assuming 'pretrain_jigsaw_dataset' is the JigsawPuzzleDataset instance\noriginal_image, _ = pretrain_dataset.dataset[0]  # Get an original image\npermuted_image, _ = pretrain_dataset[0]         # Get a permuted image\nprint(_)\nvisualize_jigsaw(original_image, permuted_image)\n\n13\n\n\n\n\n\nUsing an EfficientNet model pretrained on ImageNet\n\nfrom torchvision import models\n# Load EfficientNet model\nmodel = models.efficientnet_b0(pretrained=True)\n# Modify the last layer for permutation prediction\nnum_ftrs = model.classifier[1].in_features\nnum_permutations = 100  # Assuming 100 permutations\nmodel.classifier[1] = nn.Linear(num_ftrs, num_permutations)\npretrain_loader = DataLoader(pretrain_dataset, batch_size=32, shuffle=True)\n# Move the model to GPU if available\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nmodel = model.to(device)\n\n\ndef reassemble_patches(patches, grid_size=3):\n    \"\"\"\n    Reassemble the shuffled patches into a single image tensor.\n    Converts 5d to 4d vector\n    \"\"\"\n    batch_size, num_patches, channels, patch_height, patch_width = patches.shape\n    patches = patches.view(batch_size, grid_size, grid_size,\n                           channels, patch_height, patch_width)\n    patches = patches.permute(0, 1, 4, 2, 5, 3).contiguous()\n    patches = patches.view(batch_size, grid_size *\n                           patch_height, grid_size * patch_width, channels)\n    # Rearrange axes to [batch_size, channels, height, width]\n    patches = patches.permute(0, 3, 1, 2)\n    return patches\n\n\nimport torch.optim as optim\n\n# Loss function and optimizer\ncriterion = nn.CrossEntropyLoss()\noptimizer = optim.Adam(model.parameters(), lr=0.01)  # Using Adam optimizer\nnum_epochs = 10\nloss_list = []\nlr = []\n\n# Training loop\nfor epoch in range(num_epochs):\n    running_loss = 0.0\n    for i, (inputs, targets) in enumerate(pretrain_loader):\n        inputs = reassemble_patches(inputs, grid_size=3)\n\n        inputs, targets = inputs.to(device), targets.to(device)\n\n        # Forward pass\n        outputs = model(inputs)\n        loss = criterion(outputs, targets)\n\n        # Backward and optimize\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n        lr.append(scheduler.get_lr()[0])\n        running_loss += loss.item()\n        if i % 10 == 9:  # print every 10 mini-batches\n            print('[%d, %5d] loss: %.3f' %\n                  (epoch + 1, i + 1, running_loss / 10))\n            loss_list.append(running_loss/10)\n            running_loss = 0.0\n\n\nplt.subplot(2, 1, 1)\nplt.plot(loss_list, label='Training Loss')\nplt.title('Training Loss over Batches')\nplt.xlabel('Batch')\nplt.ylabel('Loss')\nplt.legend()\n\nplt.subplot(2, 1, 2)\nplt.plot(lr, label='Learning Rate', color='r')\nplt.title('Learning Rate over Batches')\nplt.xlabel('Batch')\nplt.ylabel('Learning Rate')\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nfrom torchvision import models\nimport torch.nn as nn\nimport torch.optim as optim\nimport torch\n\n\n# Get the number of input features to the last layer\nnum_ftrs = model.classifier[1].in_features\n\n# Reset the last layer for CIFAR-10 classification (10 classes)\nmodel.classifier[1] = nn.Linear(num_ftrs, 10)\n\n# Move the model to GPU if available\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nmodel = model.to(device)\n\n# Loss function and optimizer for fine-tuning\ncriterion = nn.CrossEntropyLoss()\n# Using Adam optimizer, LR can be adjusted as needed\noptimizer = optim.Adam(model.parameters(), lr=0.01)\n\n# Number of epochs for fine-tuning\nnum_fine_tune_epochs = 25\nloss_list = []\n\n# Fine-tuning training loop\nfor epoch in range(num_fine_tune_epochs):\n    running_loss = 0.0\n    for i, data in enumerate(train_loader, 0):\n        # Get the inputs and labels\n        inputs, labels = data\n        inputs, labels = inputs.to(device), labels.to(device)\n\n        # Zero the parameter gradients\n        optimizer.zero_grad()\n\n        # Forward pass\n        outputs = model(inputs)\n        loss = criterion(outputs, labels)\n\n        # Backward and optimize\n        loss.backward()\n        optimizer.step()\n\n        # Print statistics\n        running_loss += loss.item()\n        if i % 10 == 9:  # print every 10 mini-batches\n            print('[%d, %5d] loss: %.3f' %\n                  (epoch + 1, i + 1, running_loss / 10))\n            loss_list.append(running_loss/10)\n            running_loss = 0.0\n\n\nplt.subplot(2, 1, 1)\nplt.plot(loss_list, label='Training Loss')\nplt.title('Training Loss over Batches')\nplt.xlabel('Batch')\nplt.ylabel('Loss')\nplt.legend()\n\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\ntorch.save(model.state_dict(), './pretrained.pth')\n\nUsing an EfficientNet model without pretraining on imagenet\n\nfrom torchvision import models\n\nmodel = models.efficientnet_b0(pretrained=False)\n\nnum_ftrs = model.classifier[1].in_features\nnum_permutations = 100  # Assuming 100 permutations\nmodel.classifier[1] = nn.Linear(num_ftrs, num_permutations)\npretrain_loader = DataLoader(pretrain_dataset, batch_size=32, shuffle=True)\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nmodel = model.to(device)\n\n\nimport torch.optim as optim\n\n# Loss function and optimizer\ncriterion = nn.CrossEntropyLoss()\noptimizer = optim.Adam(model.parameters(), lr=0.01)  # Using Adam optimizer\nnum_epochs = 10\nloss_list = []\n\n# Training loop\nfor epoch in range(num_epochs):\n    running_loss = 0.0\n    for i, (inputs, targets) in enumerate(pretrain_loader):\n        inputs = reassemble_patches(inputs, grid_size=3)\n\n        inputs, targets = inputs.to(device), targets.to(device)\n\n        # Forward pass\n        outputs = model(inputs)\n        loss = criterion(outputs, targets)\n\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n\n        running_loss += loss.item()\n        if i % 10 == 9:  # print every 10 mini-batches\n            print('[%d, %5d] loss: %.3f' %\n                  (epoch + 1, i + 1, running_loss / 10))\n            loss_list.append(running_loss/10)\n            running_loss = 0.0\n\n\nplt.subplot(2, 1, 1)\nplt.plot(loss_list, label='Training Loss')\nplt.title('Training Loss over Batches')\nplt.xlabel('Batch')\nplt.ylabel('Loss')\nplt.legend()\n\nplt.subplot(2, 1, 2)\nplt.plot(lr, label='Learning Rate', color='r')\nplt.title('Learning Rate over Batches')\nplt.xlabel('Batch')\nplt.ylabel('Learning Rate')\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\nAn interesting observation is that there is hardly any drop in training loss as compared to the one with transferred weights, indicating the neural network doesn’t understand image feratures that well yet.\n\nfrom torchvision import models\nimport torch.nn as nn\nimport torch.optim as optim\nimport torch\n\n# Get the number of input features to the last layer\nnum_ftrs = model.classifier[1].in_features\n\n# Reset the last layer for CIFAR-10 classification (10 classes)\nmodel.classifier[1] = nn.Linear(num_ftrs, 10)\n\n# Move the model to GPU if available\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nmodel = model.to(device)\n\n# Loss function and optimizer for fine-tuning\ncriterion = nn.CrossEntropyLoss()\n# Using Adam optimizer, LR can be adjusted as needed\noptimizer = optim.Adam(model.parameters(), lr=0.01)\n\n# Number of epochs for fine-tuning\nnum_fine_tune_epochs = 25\nloss_list = []\n\n# Fine-tuning training loop\nfor epoch in range(num_fine_tune_epochs):\n    running_loss = 0.0\n    for i, data in enumerate(train_loader, 0):\n        # Get the inputs and labels\n        inputs, labels = data\n        inputs, labels = inputs.to(device), labels.to(device)\n\n        # Zero the parameter gradients\n        optimizer.zero_grad()\n\n        # Forward pass\n        outputs = model(inputs)\n        loss = criterion(outputs, labels)\n\n        # Backward and optimize\n        loss.backward()\n        optimizer.step()\n\n        # Print statistics\n        running_loss += loss.item()\n        if i % 10 == 9:  # print every 10 mini-batches\n            print('[%d, %5d] loss: %.3f' %\n                  (epoch + 1, i + 1, running_loss / 10))\n            loss_list.append(running_loss/10)\n            running_loss = 0.0\n\n\nplt.subplot(2, 1, 1)\nplt.plot(loss_list, label='Training Loss')\nplt.title('Training Loss over Batches')\nplt.xlabel('Batch')\nplt.ylabel('Loss')\nplt.legend()\n\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\ntorch.save(model.state_dict(), './notpretrained.pth')\n\n\nimport torch\nimport torch.nn as nn\nfrom torchvision import models\nfrom torch.utils.data import DataLoader\n\n# Define the test_model function\n\n\ndef test_model(model, dataloader, device):\n    model.eval()  # Set the model to evaluation mode\n    total_correct = 0\n    total_samples = 0\n\n    with torch.no_grad():\n        for inputs, labels in dataloader:\n            inputs, labels = inputs.to(device), labels.to(device)\n\n            outputs = model(inputs)\n            _, predicted = torch.max(outputs, 1)\n\n            total_samples += labels.size(0)\n            total_correct += (predicted == labels).sum().item()\n\n    accuracy = total_correct / total_samples\n    return accuracy\n\n\n# List of model file paths\nmodel_paths = [\n    './cifar10_5percent_scheduler_pretrained_false.pth',\n    './cifar10_5percent_adam_pretrained_true.pth',\n    './cifar10_5percent_scheduler_pretrained_true.pth',\n    './notpretrained.pth',\n    './pretrained.pth'\n]\n\n# Loop through each model\nfor model_path in model_paths:\n    # Load the EfficientNet-B0 model\n    model = models.efficientnet_b0(pretrained=False)\n\n    # Modify the classifier for CIFAR-10\n    num_ftrs = model.classifier[1].in_features\n    model.classifier[1] = nn.Linear(num_ftrs, 10)\n\n    # Load the model weights\n    model.load_state_dict(torch.load(model_path))\n\n    # Move the model to the device (e.g., GPU if available)\n    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n    model = model.to(device)\n\n    # Test the model\n    accuracy = test_model(model, test_loader, device)\n\n    # Print or store the accuracy for this model\n    print(f'Model: {model_path}, Accuracy: {accuracy*100:.2f}%')\n\nModel: ./cifar10_5percent_scheduler_pretrained_false.pth, Accuracy: 39.82%\nModel: ./cifar10_5percent_adam_pretrained_true.pth, Accuracy: 50.45%\nModel: ./cifar10_5percent_scheduler_pretrained_true.pth, Accuracy: 63.28%\nModel: ./notpretrained.pth, Accuracy: 17.29%\nModel: ./pretrained.pth, Accuracy: 46.72%\n\n\nObservations: * For training on 5% of the dataset best results are achieved when using pretrained model on imagenet that is 63% and 40% if not prior pretraining is done. * After traning on jigsaw images and then finetuning the best accuracy is 48%. This model uses transferred weights from a pretrained efficientnet on imagenet. The one without any transferred weights gets an accuracy of 34%. * Both the techniques achieve well over the baseline accuracy of 10%(random guessing).\nProposed Solutions to increase accuracy: By using the gap trick, we pad the input disordered images with zeros to the size of original images. Adopting the gap trick can discourage all the jigsaw puzzle solvers mentioned above from learning lowlevel statistics, and encourage the learning of high-level visuospatial representations of objects.\nData Augmentation can help generalising more and improve the self supervised learning."
  }
]